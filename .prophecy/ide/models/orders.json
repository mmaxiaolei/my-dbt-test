{
  "id" : "orders",
  "metainfo" : {
    "label" : "orders",
    "autoLayout" : true,
    "staleState" : "none",
    "sourceSuggestions" : {
      "sources" : [ ]
    }
  },
  "processes" : {
    "KafVMZWf" : {
      "id" : "KafVMZWf",
      "component" : "TargetModel",
      "metadata" : {
        "label" : "orders",
        "phase" : 0
      },
      "properties" : {
        "customQueryDisabled" : true,
        "customQuery" : true,
        "incrementalEditorDisabled" : true,
        "query" : "{{\n    config(\n        materialized = 'incremental',\n        unique_key = 'order_id'\n    )\n}}\n\nwith\n\n{#\n     DuckDB will see {{ this }} evaluate to `orders` and a CTE called `orders` as being the same\n     so when using DuckDB we append `_set` to any CTEs with the same name as {{ this }} to indicate\n     we're not executing a recursive statement\n#}\n\norders_set as (\n\n    select * from {{ ref('stg_orders') }}\n\n    where\n        true\n\n        {% if is_incremental() %}\n\n            and ordered_at >= (\n                select max(ordered_at) as most_recent_record from {{ this }}\n            )\n\n        {% endif %}\n\n),\n\norder_items as (\n\n    select * from {{ ref('stg_order_items') }}\n\n),\n\nproducts as (\n\n    select * from {{ ref('stg_products') }}\n\n),\n\nlocations as (\n\n    select * from {{ ref('stg_locations') }}\n\n),\n\nsupplies as (\n\n    select * from {{ ref('stg_supplies') }}\n\n),\n\norder_items_summary as (\n\n    select\n\n        order_items.order_id,\n\n        sum(products.is_food_item) as count_food_items,\n        sum(products.is_drink_item) as count_drink_items,\n        count(*) as count_items,\n        sum(\n            case\n                when products.is_food_item = 1 then products.product_price\n                else 0\n            end\n        ) as subtotal_drink_items,\n        sum(\n            case\n                when products.is_drink_item = 1 then products.product_price\n                else 0\n            end\n        ) as subtotal_food_items,\n        sum(products.product_price) as subtotal\n\n    from order_items\n\n    left join products on order_items.product_id = products.product_id\n\n    group by 1\n\n),\n\norder_supplies_summary as (\n\n    select\n\n        order_items.order_id,\n\n        sum(supplies.supply_cost) as order_cost\n\n    from order_items\n\n    left join supplies on order_items.product_id = supplies.product_id\n\n    group by 1\n\n),\n\njoined as (\n\n    select\n\n        orders_set.*,\n\n        order_items_summary.count_food_items,\n        order_items_summary.count_drink_items,\n        order_items_summary.count_items,\n\n        order_items_summary.subtotal_drink_items,\n        order_items_summary.subtotal_food_items,\n        order_items_summary.subtotal,\n\n        order_supplies_summary.order_cost,\n        locations.location_name\n\n    from orders_set\n\n    left join order_items_summary\n        on orders_set.order_id = order_items_summary.order_id\n    left join order_supplies_summary\n        on orders_set.order_id = order_supplies_summary.order_id\n    left join locations\n        on orders_set.location_id = locations.location_id\n\n),\n\nfinal as (\n\n    select\n\n        *,\n        count_food_items > 0 as is_food_order,\n        count_drink_items > 0 as is_drink_order\n\n    from joined\n\n)\n\nselect * from final\n",
        "incrementalKey" : false,
        "incremental" : {
          "expression" : "true"
        }
      },
      "ports" : {
        "inputs" : [ ],
        "outputs" : [ {
          "id" : "ppvEc7Jc",
          "slug" : "out"
        } ],
        "isCustomOutputSchema" : false
      }
    }
  },
  "connections" : [ ],
  "component" : "Model"
}